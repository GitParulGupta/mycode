Practice Resources -
https://neetcode.io/practice
https://takeuforward.org/strivers-a2z-dsa-course/strivers-a2z-dsa-course-sheet-2
Heap --> https://www.youtube.com/watch?v=hW8PrQrvMNc&list=PL_z_8CaSLPWdtY9W22VjnPxG30CXNZpI9
https://www.youtube.com/watch?v=nDswg13hZ9o&list=PLLhBy6YSIT0ANaihpjwDBSBju0qUZ82SK&index=2

**********

In any coding interview drive the solution, don't jump to solution

Brute Force
|
Better Solution
|
Optimal Solution

--- Java 17
Pair class - import javafx.util.Pair;
Pair<Integer, Integer> pair = new Pair<>(1, 2);

-- Maths
Integer.MIN_VALUE --> -2^31
Integer.MAX_VALUE --> 2^31 -1
Char a -->97, z --> 122, A --> 65, Z --> 91
character range --> 0 --> 65535

Math.min()
Math.max()
--The logarithmic base 10 of a positive integers gives the number of digits in n. We add 1 to the result to ensure that the count is correct even for numbers that are powers of 10.
return (int)(log10(n)+1); //Math.log10


-- Important search algos
1. Linear Search
2. Binary Search
3. Searching majority element -> Moore's Voting element

--Important sorting algos
1. Dutch National Flag algo
2.

-- Important operations arrays -
1. Reverse array - Collections.reverse(Arrays.asList(a)); or ArrayUtils.reverse(array);
2. To print elements of array --Arrays.toString(array)
3.

-- Important operation Lists -
1. add(int x)
2. get(index)
3. getFirst()
4. getLast()
5. remove(), removeFirst(), removeLast()
6. size()
7. Create new list => List<Integer> l = List.of(input1, input2);
7.1. Create a new List from an existing List - List<Integer> l = new ArrayList<>(existingList);
7.2. To create a synchronized list - List<Integer> l1 = Collections.synchronized(l);
8. List<Integer> l = new ArrayList<Integer>
9. List to Set in java 8 - l.stream().collect(Collectors.toSet());
10. List to Map in java 8 - l.stream().collect(Collectors.toMap(Function.identity(), Function.identity()));
11. List to String in java 8 - l.stream().map(String::valueOf).collect(Collectors.joining(", "));
12. iterate over list in java 8 - l.forEach(System.out::println);
13. List to array in java 8 - l.toArray(new Integer[0]);
14. iterator Iterator<Integer> i = elementList.iterator();
12. Sort list in java 8 - l.sort(Comparator.naturalOrder());
13. Sort list of lists in java 8 - List<List<Integer>> l=l1.stream().sorted(new Comparator<List<Integer>>() {
                                               @Override
                                               public int compare(List<Integer> o1, List<Integer> o2) {
                                                   if(!Objects.equals(o1.get(0), o2.get(0))){
                                                       return o1.get(0).compareTo(o2.get(0));
                                                   }else{
                                                       return o1.get(1).compareTo(o2.get(1));
                                                   }
                                               }
                                           }).toList();

                                       OR
                                     l.sort(Comparator.comparing(List::getFirst));
14.

--Important operations Strings -
1. String to char array - char[] c = s.toCharArray();
2. String to int - Integer.parseInt(s);
3. Check if string is palindrome - s.equals(new StringBuilder(s).reverse().toString());
4. String to List - Arrays.asList(s.split(","));
5. String to List in java 8 - Arrays.stream(s.split(",")).collect(Collectors.toList());
6. Check if String is empty -word.isEmpty()
7. String to lower or upper case - word.toLowerCase() or word.toUpperCase()
8. Sort characters of String - char[] arr = s.toCharArray();
                                      // Sort the character array
                                      Arrays.sort(arr);
                                      // Convert sorted character array back to string
                                      s = new String(arr);

-- Approaches to solve questions for arrays
1. Sum of first N numbers - eg - missingNumber
2. Xor elements eg- missingNumber, find unique element where other elements occur twice
3. Sliding Window
    -  In sliding window, if any char hash map is required, try to go by hash[26] array s.t. any hash[s.charAt(i)-'A]
4. 2 pointer

-- Recursion
1. When a function calls itself until specified condition is met, it is called recursion. Each function call creates a new stack frame, and the function continues to execute until it reaches a base case or an error occurs.
   - Base case is the condition that stops the recursion.
   - Recursive case is the part of the function that calls itself with modified parameters.
   - Example: Factorial of a number, Fibonacci series, etc.
2. Infinite recursion occurs when the base case is not defined or not reachable - leads to stack overflow exception.
3. Recursion Tree - A tree structure where each node represents a function call, and the edges represent the recursive calls made by that function.
4. Recursion vs Iteration - Recursion is often more elegant and easier to read, but it can be less efficient due to the overhead of function calls and stack space. Iteration is usually more efficient in terms of time and space complexity.
5. 2 ways to write recursion:
   - Parameterized recursion: where the function takes parameters and modifies them in each recursive call.
    - Non-parameterized recursion: function keeps track to state using return values.
    Example: Sum of first N natural numbers.

-- Hashing
1. Used to map counts of elements in an array or list.
   Example: {1,2,3,2,1} ==> n= 5, we declare an array (hash) with max capacity of n+1. for each element i in the array, hash[i]=hash[i]+1;
   - If hash array declared inside main, max size of array can be 10^6 for int. for boolean its 10^7.
   - if size of array > 10^6, then use HashMap or HashSet. TC - O(1) for operations in avg and best case and O(n) in worst.
         - If you need elements to be sorted based on key values, use TreeMap. (log(n) TC for operations)s
           If you need to preserve the order in which elements were inserted, use LinkedHashMap.
           If you are using enum keys, use EnumMap.
           If you need custom sorting, use a Stream and then collect into a LinkedHashMap.
           If you need bidirectional iteration, use OrderedMap from Apache Commons Collections.
   - If hash array declared as a global variable, max size of array can be 10^7 for int. For boolean its 10^8.
2. HashMap - A data structure that maps keys to values, allowing for fast retrieval of values based on their keys. -> nlogn TC
    - Example: HashMap<Integer, Integer> map = new HashMap<>();
    - Operations: put(key, value), get(key), remove(key), containsKey(key), size(), isEmpty(), clear().
    - Operations: putAll(map), containsKey(key), containsValue(value), Set keySet(), Collection values(), Set entrySet()
    - not thread safe. hashtable is thread safe
    - Collections.synchronized(m)
    - Iterating over a HashMap: for (Map.Entry<Integer, Integer> entry : map.entrySet()) { ... }
2.1. Identity Hashmap - same as hashmap. only difference is == used for key identification
2.2. TreeMap -- sortedMap implementation. sorting is based on keys
    - firstKey()
    - lastkey()
    - headMap(Object o)
    - tailmap(Object o)
    - subMap(Object o)
    --- baceknd ds - Red black tree
2.3. Navigable Map -
    - floorKey(e)
    - lowerKey(e)
    - ceilingKey(e)
    - higherKey(e)
    - pollFirstEntry()
    - pollLastEntry()
    - descendingMap()
3. HashSet - A data structure that stores unique elements, allowing for fast membership testing and insertion. -> nlogn TC
    - Example: HashSet<Integer> set = new HashSet<>();
    - Operations: add(element), remove(element), contains(element), size(), isEmpty(), clear().
    - Iterating over a HashSet: for (Integer element : set) { ... }
3.1 Sorted hashSet - implementation is TreeSet - elements are preserved according to some sorted order.
    - first(), last(), headSet(Object o) --> elements before o, tailSet(Object o)--elements >= o, subset(Object o1, Object o2) -- including o1 excluding o2
    - null not allowed
    - underlying ds is TreeMap
3.2. Navigable Set - child interface of sorted set
    - floor(Object e) - returns highest elements less than or equal to e
    - lower(Object e) - returns highest elements less than e
    - ceiling(Object e) - returns highest elements greater than or equal to e
    - higher(Object e) - returns highest elements greater than e
    - pollFirst() - remove and return the first element
    - pollLast() - remove and return the last element
    - descendingSet() - returns navigable set in descending order
4. Character Hashing - Used to map characters to their ASCII values or to count occurrences of characters in a string.
    - Example: int[] hash = new int[256]; // for ASCII characters - 'a'--> 97 to 'z' --> 122 & 'A' --> 65 to 'Z' --> 90
    - Lets assume array has only lowercase characters, then we can use a smaller array of size 26.
            - Example: int[] hash = new int[26]; // for lowercase characters
            - To map a character c to its index in the array, use hash[c - 'a'].
    - For each character c in the string, hash[c]++;
    - To check if a character exists, use hash[c] > 0.
5. Collisions - Handling collisions in array - Division method, Multiplication method, and Universal hashing.
    - Division method: hash(key) = key % size_of_array - if still collision occurs, use linear probing or chaining.
    - Multiplication method: hash(key) = floor(size_of_array * (key * A % 1))
    - Universal hashing: Use a random function to map keys to indices in the array.
6. HashTable - keys are hashcode of elements
    - synchronized
    - best for search operations

-- Queue
- FIFO
- offer(Object o)
- poll()
- remove() - if queue is empty - poll returns null vs remove returns NoSuchElementException
- peek() - top of set. Returns null if empty
- element() - returns top of set. noSuchElementException if empty

-- Heap
- For question related to heap, implementation using stack. Look for keywords K and smallest/largest
- 2 types of heaps:
    - Min Heap - The smallest element is at the top. K+largest in keywords
    - Max Heap - The largest element is at top. K + smallest in keywords
- all questions basically of sorting. nlogn complexity
- Heap is of fixed size k. Complexity is nlogk
- Ex: Kth smallest element
    - ar[7,10,4,3,20,15]
    - k = 3
    - we need to find 3rd smallest element
    - Create a max heap of size k - max element at top
    - option 1 => srt the array and return ar[k-1] but tiome complexity is nlogn
    - option 2 => heap ->
        - Create a max heap of size k
        - Insert first k elements into the heap
        - For each remaining element in the array, if it is smaller than the top of the heap, replace the top with the new element and re-heapify(Arrange itself).
        - After processing all elements, the root of the heap will be the kth smallest element.
- Defining Heaps
    - minHeap --> PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    - maxHeap --> PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
                                                or
                  PriorityQueue<Integer> maxHeap = new PriorityQueue<>(K, (o1,o1)->o2-o1); //here k is the initial heap capacity and comparator sorts elements in reverse order
- Common heap operations:
    - add: O(log n)
    - poll: O(log n)
    - peek (get the top element): O(1)
    - size: O(n)

-- Binary Trees
- Binary Tree is a data structure where each node has at most two children, referred to as the left child and the right child.
- Head of the tree is the root node.
- Leaf nodes are nodes that do not have any children.
- Subtree is a tree formed by a node and all its descendants.
- Ancestor of a node is any node on the path from the root to that node.
- 5 types of binary trees:
    1. Full Binary Tree: Every node has either 0 or 2 children.
    2. Complete Binary Tree: All levels are completely filled except possibly the last level, which is filled from left to right.
    3. Perfect Binary Tree: All internal nodes have two children and all leaf nodes are at the same level.
    4. Balanced Binary Tree: The height of the left and right subtrees of any node differ by at most one. - height can be a max of log(n) for balanced tree. ex: nodes = 8 ==> height --> at max 3
    5. Degenerate (or pathological) Tree: Each parent node has only one child -like a linked list.
- Tree Traversal:
    1. Depth-First Search (DFS):
        - Pre-order: Visit the root, then the left subtree, and finally the right subtree. -- root, left, right
        - In-order: Visit the left subtree, then the root, and finally the right subtree. - left, root, right
        - Post-order: Visit the left subtree, then the right subtree, and finally the root. --left,right, root
    2. Breadth-First Search (BFS):
        - Level-order: Visit all nodes at the present depth level before moving on to nodes at the next depth level.

-- Binary Search Trees (BST):
- A binary tree where for each node, the left subtree contains only nodes with values less than the node's value, and the right subtree contains only nodes with values greater than the node's value.
- Entire left sub tree should be a BST and entire right sub tree should be a BST
- If duplicates are allowed condition is modified to left subtree contains nodes with values less than or equal to the node's value && right subtree contains nodes with values greater than or equal to the node's value.
   - In ideal case nodes are not duplicates
- Height of BST is O(log n) in average case and O(n) in worst case (when the tree becomes skewed/degenrate trees).
- Common operations:
    - Search: O(h) where h is the height of the tree.
    - Insertion: O(h)
    - Deletion: O(h)
    - Traversal: O(n)


-- Graphs
- A graph is a data structure that consists of a set of nodes (or vertices) and a set of edges that connect pairs of nodes.
- Types of Graphs:
    1. Directed Graph (Digraph): Edges have a direction, going from one vertex to another. All edges are directed. Can be bidirectional edges as well
            X --> X
            ^
            |
            X
    2. Undirected Graph: Edges do not have a direction; they connect two vertices bidirectionally.
        - A BT is also an undirected graph
        -   X -- X
            | /  |
            X
    3. Cyclic Graph: A graph that contains at least one cycle (a path that starts and ends at the same vertex). It may be directed or undirected.
    4. Acyclic Graph: A graph that does not contain any cycles. It may be directed or undirected.
        - DAG - Directed Acyclic Graph
- Path:Contain lot of nodes and vertices and each of them are reachable from one another
- Degrees in Graphs directed and undirected:
    - Undirected Graph:
        - Degree of a vertex: Number of edges connected to the vertex.
        - Total degree of graph = 2 * number of edges
    - Directed Graph:
        - In-degree: Number of edges directed towards a vertex.
        - Out-degree: Number of edges directed away from a vertex.
        - Total degree of graph = 2 * number of edges
- Edge Weights:
    - Unweighted Graph: All edges are considered to have the same weight or cost i.e. unit weights i.e. 1.
    - Weighted Graph: Each edge has an associated weight or cost, which can represent distance, time, or any other metric.

- Graph Representation:
    1. Adjacency Matrix: A 2D array where the cell at row i and column j indicates the presence (and possibly weight) of an edge between vertex i and vertex j.
        - Space Complexity: O(V^2) where V is the number of vertices.
        - Time Complexity: O(1) for checking the existence of an edge, O(V) for finding all neighbors of a vertex.
    2. Adjacency List: An array of lists where each index represents a vertex, and the list at that index contains the neighbors of that vertex.
        - Space Complexity: O(V + E) where V is the number of vertices and E is the number of edges.
        - Time Complexity: O(V) for checking the existence of an edge, O(k) for finding all neighbors of a vertex, where k is the number of neighbors.
- Visted Array - boolean[] visited = new boolean[V]; // where V is the number of vertices in the graph
            for(int i=0;i<V;i++){
                visited[i] = false;
            }
            //on visiting a node
            visited[node] = true;
            //Traversal algo
            for(int neighbor : adj.get(node)){
                if(!visited[neighbor]){
                    //visit the neighbor
                }
            }
- Common Graph Algorithms:
    1. Depth-First Search (DFS): Explores as far as possible along each branch before backtracking. Can be implemented using recursion or a stack.
        - Time Complexity: O(V + E)
        - Space Complexity: O(V) for the recursion stack or explicit stack.
    2. Breadth-First Search (BFS): Explores all neighbors at the present depth level before moving on to nodes at the next depth level. Implemented using a queue.
        - Time Complexity: O(V + E)
        - Space Complexity: O(V) for the queue.
        - Also called Level wise traversal
        - start node is at level 0, its neighbors are at level 1 (distance from start node), their unvisited neighbors are at level 2, and so on.
    3. Dijkstra's Algorithm: Finds the shortest path from a source vertex to all other vertices in a weighted graph with non-negative weights.
        - Time Complexity: O((V + E) log V) using a priority queue.
        - Space Complexity: O(V) for the distance array and priority queue.
    4. Bellman-Ford Algorithm: Finds the shortest path from a source vertex to all other vertices in a weighted graph, even with negative weights.
        - Time Complexity: O(V * E)
        - Space Complexity: O(V) for the distance array.
    5. Floyd-Warshall Algorithm: Finds shortest paths between all pairs of vertices in a weighted graph.
        - Time Complexity: O(V^3)
        - Space Complexity: O(V^2) for the distance matrix.
    6. Topological Sort: Orders the vertices of a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before v in the ordering. Can be implemented using DFS or Kahn's algorithm (BFS).
        - Time Complexity: O(V + E)
        - Space Complexity: O(V) for the stack or queue and in-degree array.
    7. Union-Find (Disjoint Set Union - DSU): A data structure that keeps track of elements partitioned into disjoint sets, supporting union and find operations.
        - Time Complexity: O(α(n)) per operation, where α is the inverse Ackermann function.
        - Space Complexity: O(n) for the parent and rank arrays.
    8. Prim's Algorithm: Finds the minimum spanning tree (MST) of a weighted undirected graph. It starts from an arbitrary vertex and grows the MST by adding the smallest edge that connects a vertex in the MST to a vertex outside the MST.
        - Time Complexity: O((V + E) log V) using a priority queue.
        - Space Complexity: O(V) for the key, parent, and inMST arrays.
    9. Kruskal's Algorithm: Finds the minimum spanning tree (MST) of a weighted undirected graph by sorting all edges and adding them one by one, ensuring no cycles are formed using the union-find data structure.
        - Time Complexity: O(E log E) or O(E log V) using union-find.
        - Space Complexity: O(V) for the parent and rank arrays in union-find.

Minimum Spanning Tree -
- Spanning Tree - A tree in which we have N nodes and N-1 edges and all nodes are reachable from each other
- MST - Spanning tree which has minmum sum of all the edges
- refer -> mst.png for mst example
- ways to find mst -
    - Prim's algorithm
    - Kruskal's algorithm
- Disjoint Set - usually used in dynamic graphs - which keep on changing
-